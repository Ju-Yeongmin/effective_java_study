# Item 86
## Serializable을 구현할지는 신중히 결정하라

### 직렬화는 쉽다?
어떤 클래스의 인스턴스를 직렬화하려면 implements Serializable만 붙이면 된다
- 사용이 굉장히 쉽기 때문에 특별히 신경쓸게 없다고 오해할 수 있다
- 하지만 실제론 훨씬 복잡하다
- 직렬화를 지원하는것은 짧게보면 쉬워보이지만 길게보면 아주 값비싼 일이다

### 직렬화를 신중하게 써야하는 이유
**1. Serializable을 구현하고 릴리스한 뒤에는 수정이 매우 어렵다**
- 직렬화 형태도 하나의 공개 API가 되어 영원히 지원해야 한다
  - 직렬화를 하면 클래스의 private, protected 필드들도 API로 공개되어 캡슐화가 깨진다
  - 내부 구현을 수정하면 원래의 직렬화 형태와 달라지게된서 수정할 수 없다
- 모든 직렬화된 클래스는 고유 식별 번호를 부여받는데, 이 변호를 명시하지 않으면 문제가 생긴다
  - 시스템이 런타임에 암호 해시함수를 적용하여 자동으로 클래스안에 생성한다
  - 이 값 생성에는 클래스 이름, 클래스 멤버 등이 고려된다
  - 따라서 나중에 클래스 내부 구현을 손보면 직렬버전 고유 식별번호가 바뀐다
  - 즉, 자동 생성값에 의존하면 호환성이 깨져 런타임시에 에러가 발생한다

<br>

**2. Serializable 구현은 버그와 보안 구멍이 생길 위험이 높다**
- 직렬화는 언어의 기본 생성 매커니즘(생성자로 객체를 만드는 것)을 우회하는 객체 생성 기법이다
- 역직렬화는 일반 생성자의 문제가 그대로 적용되는 숨은 생성자를 사용하는 것으로, 보안적으로 취약하다

<br>


**3. Serializable 구현은 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다**
- 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화 한 후 구버전으로 역직렬화가 가능한지 테스트해야 한다

<br>


**4. Serializable 구현 여부는 가볍게 결정할 사안이 아니다**
- 객체를 전송/저장 시 자바 직렬화를 이용하는 프레임워크용으로 직렬화를 반드시 구현해야 한다면 선택의 여지가 없다
- 하지만 Serializable 구현 비용이 적지 않으니 이득과 비용을 잘 따져서 설계하자

<br>


**5. 상속용 클래스는 대부분 직렬화를 구현하면 안된다**
- 인터페이스도 대부분 Serializable을 확장하면 안된다
- 클래스를 확장하거나 인터페이스를 구현할 때 부담이 되기 때문
- (Serializable을 구현한 클래스만 지원하는 프레임워크를 사용한다면 예외)

<br>


**6. 내부 클래스는 직렬화를 구현하지 말아야 한다**
- 내부 클래스에는 바깥 인스턴스의 참조와 유효범위 안의 지역번수 값들을 저장하기 위해 컴파일러가 생성한 필드가 자동 추가 된다
- 이 필드들이 클래스 정의에 어떻게 추가되는지 정의되자 않는다
- 따라서 내부 클래스에 대한 직렬화 형태가 분명하지 않다
- 단, 정적 멤버 클래스는 직렬화를 구현해도 된다

<br>


```java
핵심!

Serializable를 구현하기는 쉬워보이지만 눈속임일 뿐 굉장히 복잡하고 비용이 크다.
한 클래스가 여러버전과 상호작용 할 일이 없고, 신뢰할 수 없는 데이터에 노출될 일이 없는
보호된 환경에서만 쓸게 아니라면 Serializable은 아주 신중하게 구현하자
```
